<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_fixed_point_c___reference"><title>Boost.Fixed_point C++ Reference</title><header name="boost/fixed_point/fixed_point.hpp">
<namespace name="boost">
<namespace name="fixed_point">
<class name="negatable"><template>
      <template-nontype-parameter name="integral_range"><type>const int</type><purpose><para>Integer g &gt;= 0 defines a range of sign number n that is 2^-g &lt; n &lt; 2^g. </para></purpose></template-nontype-parameter>
      <template-nontype-parameter name="fractional_resolution"><type>const int</type><purpose><para>Integer s &lt;= -1 defines resolution. The resolution of a fractional number is 2^s. </para></purpose></template-nontype-parameter>
      <template-type-parameter name="round_mode"><default><classname alt="boost::fixed_point::round::fastest">round::fastest</classname></default><purpose><para>struct defining the rounding behaviour, default <classname alt="boost::fixed_point::round::fastest">round::fastest</classname>. </para></purpose></template-type-parameter>
      <template-type-parameter name="overflow_mode"><default><classname alt="boost::fixed_point::overflow::undefined">overflow::undefined</classname></default><purpose><para>struct defining the behaviour from rounding, default <classname alt="boost::fixed_point::overflow::undefined">overflow::undefined</classname>. </para></purpose></template-type-parameter>
    </template><purpose>Fixed_point class used for signed fractional arithmetic. </purpose><description><para>TODO some examples here? 
</para></description><struct name="constant_maker"><template>
      <template-nontype-parameter name="bit_count"><type>const int</type><purpose><para>Precision in bits to create. </para></purpose></template-nontype-parameter>
      <template-type-parameter name="enable_type"><purpose><para>Used internally to enable the most suitable version for the value of bit_count. </para></purpose></template-type-parameter>
    </template><description><para>Construct a constant of type negatable using values of constants from <ulink url="http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/constants.html">boost::math::constants</ulink><sbr/>
It is a private member of class negatable because it is not normally needed by users who just want to <emphasis role="bold">call</emphasis> a function. It <emphasis role="bold">is</emphasis> required to add new constants. 
</para></description></struct><struct name="nothing"/><typedef name="value_type"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="float_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="get_data" cv="const"><type>const value_type &amp;</type></method>
<method name="operator++"><type><classname>negatable</classname> &amp;</type></method>
<method name="operator--"><type><classname>negatable</classname> &amp;</type></method>
<method name="operator++"><type><classname>negatable</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator--"><type><classname>negatable</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator+="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator-="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator*="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator/="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator+="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="operator-="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="operator*="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="operator/="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="conversion-operator" cv="const"><type>char</type></method>
<method name="conversion-operator" cv="const"><type>short</type></method>
<method name="conversion-operator" cv="const"><type>int</type></method>
<method name="conversion-operator" cv="const"><type>long</type></method>
<method name="conversion-operator" cv="const"><type>long long</type></method>
<method name="conversion-operator" cv="const"><type>unsigned char</type></method>
<method name="conversion-operator" cv="const"><type>unsigned short</type></method>
<method name="conversion-operator" cv="const"><type>unsigned int</type></method>
<method name="conversion-operator" cv="const"><type>unsigned long</type></method>
<method name="conversion-operator" cv="const"><type>unsigned long long</type></method>
<method name="conversion-operator" cv="const"><type>float</type></method>
<method name="conversion-operator" cv="const"><type>double</type></method>
<method name="conversion-operator" cv="const"><type>long double</type></method>
<method name="bit_pattern"><type>std::string</type></method>
</method-group>
<constructor/>
<constructor><template>
          <template-type-parameter name="integral_type"/>
        </template><parameter name="u"><paramtype>const integral_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt;(   std::is_integral&lt; integral_type &gt;::value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp;std::is_unsigned&lt; integral_type &gt;::value)&gt;::type *</paramtype><default>nullptr</default></parameter></constructor>
<constructor><template>
          <template-type-parameter name="integral_type"/>
        </template><parameter name="n"><paramtype>const integral_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt; (   std::is_integral&lt; integral_type &gt;::value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp;std::is_signed&lt; integral_type &gt;::value)||std::is_same&lt; integral_type, value_type &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter></constructor>
<constructor><template>
          <template-type-parameter name="floating_point_type"/>
        </template><parameter name="f"><paramtype>const floating_point_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt; std::is_floating_point&lt; floating_point_type &gt;::value||std::is_same&lt; floating_point_type, float_type &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter></constructor>
<constructor><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-nontype-parameter name="m_range"><type>int</type></template-nontype-parameter>
          <template-nontype-parameter name="m_resolution"><type>int</type></template-nontype-parameter>
          <template-type-parameter name="m_round"/>
          <template-type-parameter name="m_overflow"/>
          <template-type-parameter name="std::enable_if&lt; std::is_same&lt; m_round, round_mode &gt;::value &amp;&amp;std::is_same&lt; m_overflow, overflow_mode &gt;::value &amp;&amp;m_range&lt;=integral_range &amp;&amp;m_resolution &gt;=fractional_resolution &gt;::type *"><default>nullptr</default></template-type-parameter>
        </template><parameter name="rhs"><paramtype>const <classname>negatable</classname>&lt; m_range, m_resolution, m_round, m_overflow &gt; &amp;</paramtype></parameter><description><para>Mixed constructors Constructor from a negatable with larger range AND resolution </para></description></constructor>
<constructor><template>
          <template-nontype-parameter name="m_range"><type>int</type></template-nontype-parameter>
          <template-nontype-parameter name="m_resolution"><type>int</type></template-nontype-parameter>
          <template-type-parameter name="m_round"/>
          <template-type-parameter name="m_overflow"/>
          <template-type-parameter name="std::enable_if&lt; !(std::is_same&lt; m_round, round_mode &gt;::value &amp;&amp;std::is_same&lt; m_overflow, overflow_mode &gt;::value &amp;&amp;m_range&lt;=integral_range &amp;&amp;m_resolution &gt;=fractional_resolution) &gt;::type *"><default>nullptr</default></template-type-parameter>
        </template><parameter name="rhs"><paramtype>const <classname>negatable</classname>&lt; m_range, m_resolution, m_round, m_overflow &gt; &amp;</paramtype></parameter></constructor>
<destructor/>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const char &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const short &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const int &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const long long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned char &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned short &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned int &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned long long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="f"><paramtype>const float &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="d"><paramtype>const double &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="ld"><paramtype>const long double &amp;</paramtype></parameter></copy-assignment>
<method-group name="private static functions">
<method name="unsigned_small_mask" cv="noexcept" specifiers="static"><type>const unsigned_small_type &amp;</type></method>
<method name="binary_round" specifiers="static"><type>boost::int_fast8_t</type><template>
          <template-type-parameter name="local_round_mode"><default>round_mode</default></template-type-parameter>
        </template><parameter name="u_round"><paramtype>unsigned_small_type &amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; std::is_same&lt; local_round_mode, <classname>round::fastest</classname> &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter><description><para>Here, u_round contains the value to be rounded whereby this value is left-shifted one binary digit larger than the final result will be.</para><para>Perform the rounding algorithm for <classname alt="boost::fixed_point::round::fastest">round::fastest</classname>. For <classname alt="boost::fixed_point::round::fastest">round::fastest</classname>, there is simply no rounding at all. The value is truncated.</para></description></method>
<method name="binary_round" specifiers="static"><type>boost::int_fast8_t</type><template>
          <template-type-parameter name="local_round_mode"><default>round_mode</default></template-type-parameter>
        </template><parameter name="u_round"><paramtype>unsigned_small_type &amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; std::is_same&lt; local_round_mode, <classname>round::nearest_even</classname> &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter><description><para>Here, u_round contains the value to be rounded whereby this value is left-shifted one binary digit larger than the final result will be.</para><para>Perform the rounding algorithm for <classname alt="boost::fixed_point::round::nearest_even">round::nearest_even</classname>. For <classname alt="boost::fixed_point::round::nearest_even">round::nearest_even</classname>, the value is rounded to larger absolute value when both 1/2-ULP as well as 1-ULP are 1, representing round odd 1-ULP to higher value.</para></description></method>
<method name="radix_split_value" specifiers="static"><type>const arithmetic_type &amp;</type><template>
          <template-type-parameter name="arithmetic_type"/>
        </template></method>
<method name="epsilon_maker" cv="noexcept" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="value_min" cv="noexcept" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="value_max" cv="noexcept" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
</method-group>
<method-group name="private member functions">
<method name="convert_to_floating_point_type" cv="const"><type>floating_point_type</type><template>
          <template-type-parameter name="floating_point_type"/>
        </template></method>
<method name="make_from_floating_point_type"><type>void</type><template>
          <template-type-parameter name="floating_point_type"/>
        </template><parameter name="f"><paramtype>const floating_point_type &amp;</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="integral_type"><purpose><para>Integer type on which the fixed-point type is based, typically the native unsigned integer type unsigned int, but can be a smaller fundamental type like short int, or a much longer type like boost::multiprecision::cpp_int. </para></purpose></template-type-parameter>
        </template><parameter name=""><paramtype>const <classname>nothing</classname> &amp;</paramtype></parameter><parameter name="n"><paramtype>const integral_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt; std::is_integral&lt; integral_type &gt;::value||std::is_same&lt; typename negatable::value_type, integral_type &gt;::value||std::is_same&lt; typename negatable::unsigned_small_type, integral_type &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter><description><para>
<para><emphasis role="bold">See Also:</emphasis><para><ulink url="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html">http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html</ulink> </para></para>
</para></description></constructor>
</class><namespace name="overflow">
<struct name="exception"><purpose>Template parameter for fixed_point negatable.<sbr/>
 If the dynamic value exceeds the range of the variable, throw an exeception of type <computeroutput>std::overflow_error</computeroutput>. </purpose></struct><struct name="impossible"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Programmer analysis of the program has determined that overflow cannot occur. Uses of this mode should be accompanied by an argument supporting the conclusion. </purpose></struct><struct name="modulus"><purpose>Template parameter for fixed_point negatable.<sbr/>
 The assigned value is the dynamic value mod the range of the variable. This mode makes sense only with unsigned numbers. It is useful for angular measures. </purpose></struct><struct name="saturate"><purpose>Template parameter for fixed_point negatable.<sbr/>
 If the dynamic value exceeds the range of the variable, assign the nearest representable value. </purpose></struct><struct name="undefined"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Programmers are willing to accept undefined behavior in the event of an overflow. </purpose></struct></namespace>
<namespace name="round">
<struct name="classic"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Template parameter for fixed_point negatableRound towards the nearest value, but exactly-half values are rounded towards maximum magnitude. This mode is the standard school algorithm. </purpose></struct><struct name="fastest"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Speed is more important than the choice in value. </purpose></struct><struct name="nearest_even"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Round towards the nearest value, but exactly-half values are rounded towards even values. This mode has more balance than the classic mode. </purpose></struct><struct name="nearest_odd"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Round towards the nearest value, but exactly-half values are rounded towards odd values. This mode has as much balance as the near_even mode, but preserves more information. </purpose></struct><struct name="negative"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Round towards negative infinity. This mode is useful in interval arithmetic. </purpose></struct><struct name="positive"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Round towards positive infinity. This mode is useful in interval arithmetic. </purpose></struct><struct name="truncated"><purpose>Template parameter for fixed_point negatable.<sbr/>
 Template parameter for fixed_point negatableRound towards zero. This mode is useful in implementing integral arithmetic. </purpose></struct></namespace>
<function name="abs"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter></function>
<function name="fabs"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter></function>
<function name="frexp"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter><parameter name="expptr"><paramtype>int *</paramtype></parameter></function>
<function name="ldexp"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter><parameter name="exp"><paramtype>int</paramtype></parameter></function>
<function name="sqrt"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter></function>
</namespace>
</namespace>
<namespace name="std">
<class-specialization name="numeric_limits"><template>
      <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
      <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
    </template><specialization><template-arg>boost::fixed_point::negatable&lt; integral_range</template-arg><template-arg>fractional_resolution</template-arg><template-arg>boost::fixed_point::round::fastest</template-arg><template-arg>boost::fixed_point::overflow::undefined &gt;</template-arg></specialization><description><para><note><para>Individual template specializations need to be provided for each different rounding mode and overflow mode. This might be 7 rounding * 5 overflow, a total of 35 specializations! </para></note>
</para></description><data-member name="is_specialized" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="digits" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="is_signed" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_integer" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_exact" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="radix" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="has_infinity" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_quiet_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_signaling_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_denorm" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_denorm_style</type></data-member>
<data-member name="has_denorm_loss" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_iec559" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_bounded" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_modulo" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="traps" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="tinyness_before" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="round_style" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_round_style</type></data-member>
<method-group name="public static functions">
<method name="min" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type()</type></method>
<method name="max" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type()</type></method>
<method name="lowest" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="epsilon" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="round_error" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="infinity" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="quiet_NaN" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
</method-group>
</class-specialization><class-specialization name="numeric_limits"><template>
      <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
      <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
    </template><specialization><template-arg>boost::fixed_point::negatable&lt; integral_range</template-arg><template-arg>fractional_resolution</template-arg><template-arg>boost::fixed_point::round::nearest_even</template-arg><template-arg>boost::fixed_point::overflow::undefined &gt;</template-arg></specialization><data-member name="is_specialized" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="digits" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="is_signed" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_integer" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_exact" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="radix" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="has_infinity" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_quiet_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_signaling_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_denorm" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_denorm_style</type></data-member>
<data-member name="has_denorm_loss" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_iec559" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_bounded" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_modulo" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="traps" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="tinyness_before" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="round_style" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_round_style</type></data-member>
<method-group name="public static functions">
<method name="min" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type()</type></method>
<method name="max" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type()</type></method>
<method name="lowest" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="epsilon" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="round_error" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="infinity" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
<method name="quiet_NaN" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST negatable_type</type></method>
</method-group>
</class-specialization></namespace>
</header>
</library-reference>
