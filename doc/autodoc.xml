<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_fixed_point_c___reference"><title>Boost.Fixed_point C++ Reference</title><header name="boost/fixed_point/fixed_point.hpp">
<namespace name="boost">
<namespace name="fixed_point">
<class name="negatable"><template>
      <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
      <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
      <template-type-parameter name="round_mode"><default><classname alt="boost::fixed_point::round::fastest">round::fastest</classname></default></template-type-parameter>
      <template-type-parameter name="overflow_mode"><default><classname alt="boost::fixed_point::overflow::undefined">overflow::undefined</classname></default></template-type-parameter>
    </template><struct name="constant_maker"><template>
      <template-nontype-parameter name="bit_count"><type>const int</type></template-nontype-parameter>
      <template-type-parameter name="enable_type"><default>void</default></template-type-parameter>
    </template><method-group name="public static functions">
<method name="pi" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="ln_two" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
</method-group>
</struct><struct-specialization name="constant_maker"><template>
      <template-nontype-parameter name="bit_count"><type>const int</type></template-nontype-parameter>
    </template><specialization><template-arg>bit_count</template-arg><template-arg>typename std::enable_if&lt;(bit_count &gt; 16)&amp;&amp;(bit_count&lt;=32)&gt;::type</template-arg></specialization><method-group name="public static functions">
<method name="pi" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="ln_two" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
</method-group>
</struct-specialization><struct-specialization name="constant_maker"><template>
      <template-nontype-parameter name="bit_count"><type>const int</type></template-nontype-parameter>
    </template><specialization><template-arg>bit_count</template-arg><template-arg>typename std::enable_if&lt;(bit_count &gt; 32)&amp;&amp;(bit_count&lt;=64)&gt;::type</template-arg></specialization><method-group name="public static functions">
<method name="pi" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="ln_two" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
</method-group>
</struct-specialization><struct-specialization name="constant_maker"><template>
      <template-nontype-parameter name="bit_count"><type>const int</type></template-nontype-parameter>
    </template><specialization><template-arg>bit_count</template-arg><template-arg>typename std::enable_if&lt;(bit_count &gt; 8)&amp;&amp;(bit_count&lt;=16)&gt;::type</template-arg></specialization><method-group name="public static functions">
<method name="pi" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="ln_two" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
</method-group>
</struct-specialization><struct name="nothing"/><typedef name="value_type"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="float_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="operator++"><type><classname>negatable</classname> &amp;</type></method>
<method name="operator--"><type><classname>negatable</classname> &amp;</type></method>
<method name="operator++"><type><classname>negatable</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator--"><type><classname>negatable</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator+="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator-="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator*="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator/="><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></method>
<method name="operator+="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="operator-="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="operator*="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="operator/="><type><classname>negatable</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="n"><paramtype>T &amp;</paramtype></parameter></method>
<method name="conversion-operator" cv="const"><type>char</type></method>
<method name="conversion-operator" cv="const"><type>short</type></method>
<method name="conversion-operator" cv="const"><type>int</type></method>
<method name="conversion-operator" cv="const"><type>long</type></method>
<method name="conversion-operator" cv="const"><type>long long</type></method>
<method name="conversion-operator" cv="const"><type>unsigned char</type></method>
<method name="conversion-operator" cv="const"><type>unsigned short</type></method>
<method name="conversion-operator" cv="const"><type>unsigned int</type></method>
<method name="conversion-operator" cv="const"><type>unsigned long</type></method>
<method name="conversion-operator" cv="const"><type>unsigned long long</type></method>
<method name="conversion-operator" cv="const"><type>float</type></method>
<method name="conversion-operator" cv="const"><type>double</type></method>
<method name="conversion-operator" cv="const"><type>long double</type></method>
<method name="bit_pattern"><type>std::string</type></method>
</method-group>
<constructor/>
<constructor><template>
          <template-type-parameter name="integral_type"/>
        </template><parameter name="u"><paramtype>const integral_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt;(   std::is_integral&lt; integral_type &gt;::value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp;std::is_unsigned&lt; integral_type &gt;::value)&gt;::type *</paramtype><default>nullptr</default></parameter></constructor>
<constructor><template>
          <template-type-parameter name="integral_type"/>
        </template><parameter name="n"><paramtype>const integral_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt; (   std::is_integral&lt; integral_type &gt;::value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   &amp;&amp;std::is_signed&lt; integral_type &gt;::value)||std::is_same&lt; integral_type, value_type &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter></constructor>
<constructor><template>
          <template-type-parameter name="floating_point_type"/>
        </template><parameter name="f"><paramtype>const floating_point_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt; std::is_floating_point&lt; floating_point_type &gt;::value||std::is_same&lt; floating_point_type, float_type &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter></constructor>
<constructor><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></constructor>
<destructor/>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="v"><paramtype>const <classname>negatable</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const char &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const short &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const int &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="n"><paramtype>const long long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned char &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned short &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned int &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="u"><paramtype>const unsigned long long &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="f"><paramtype>const float &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="d"><paramtype>const double &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>negatable</classname> &amp;</type><parameter name="ld"><paramtype>const long double &amp;</paramtype></parameter></copy-assignment>
<method-group name="private static functions">
<method name="unsigned_small_mask" cv="noexcept" specifiers="static"><type>unsigned_small_type</type></method>
<method name="binary_round" specifiers="static"><type>boost::int_fast8_t</type><template>
          <template-type-parameter name="local_round_mode"><default>round_mode</default></template-type-parameter>
        </template><parameter name="u_round"><paramtype>unsigned_small_type &amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; std::is_same&lt; local_round_mode, <classname>round::fastest</classname> &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter><description><para>Here, u_round contains the value to be rounded whereby this value is left-shifted one binary digit larger than the final result will be.</para><para>Perform the rounding algorithm for <classname alt="boost::fixed_point::round::fastest">round::fastest</classname>. For <classname alt="boost::fixed_point::round::fastest">round::fastest</classname>, there is simply no rounding at all. The value is truncated.</para></description></method>
<method name="binary_round" specifiers="static"><type>boost::int_fast8_t</type><template>
          <template-type-parameter name="local_round_mode"><default>round_mode</default></template-type-parameter>
        </template><parameter name="u_round"><paramtype>unsigned_small_type &amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; std::is_same&lt; local_round_mode, <classname>round::nearest_even</classname> &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter><description><para>Here, u_round contains the value to be rounded whereby this value is left-shifted one binary digit larger than the final result will be.</para><para>Perform the rounding algorithm for <classname alt="boost::fixed_point::round::nearest_even">round::nearest_even</classname>. For <classname alt="boost::fixed_point::round::nearest_even">round::nearest_even</classname>, the value is rounded to larger absolute value when both 1/2-ULP as well as 1-ULP are 1, representing round odd 1-ULP to higher value.</para></description></method>
<method name="radix_split_value" specifiers="static"><type>const arithmetic_type &amp;</type><template>
          <template-type-parameter name="arithmetic_type"/>
        </template></method>
<method name="epsilon_maker" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="value_min" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="value_max" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
<method name="value_pi" specifiers="static"><type>const <classname>negatable</classname></type><parameter name=""><paramtype>nothing()</paramtype></parameter><parameter name=""><paramtype>value_type((UINT8_C(0x64)+((UINT8_C(1)&lt;&lt; (5+fractional_resolution))/2U)) &gt;&gt;(5+fractional_resolution))</paramtype></parameter></method>
<method name="ln_two" specifiers="static"><type>const <classname>negatable</classname> &amp;</type></method>
</method-group>
<method-group name="private member functions">
<method name="convert_to_floating_point_type" cv="const"><type>floating_point_type</type><template>
          <template-type-parameter name="floating_point_type"/>
        </template></method>
<method name="make_from_floating_point_type"><type>void</type><template>
          <template-type-parameter name="floating_point_type"/>
        </template><parameter name="f"><paramtype>const floating_point_type &amp;</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="integral_type"><purpose><para>Integer type on which the fixed-point type is based, typically the native unsigned integer type unsigned int, but can be a smaller fundamental type like short int, or a much longer type like boost::multiprecision::cpp_int. </para></purpose></template-type-parameter>
        </template><parameter name=""><paramtype>const nothing &amp;</paramtype></parameter><parameter name="n"><paramtype>const integral_type &amp;</paramtype></parameter><parameter name=""><paramtype>const typename std::enable_if&lt; std::is_integral&lt; integral_type &gt;::value||std::is_same&lt; value_type, integral_type &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter><description><para>
<para><emphasis role="bold">See Also:</emphasis><para><ulink url="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html">http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html</ulink> </para></para>
</para></description></constructor>
</class><namespace name="overflow">
<struct name="exception"/><struct name="impossible"/><struct name="modulus"/><struct name="saturate"/><struct name="undefined"/></namespace>
<namespace name="round">
<struct name="classic"/><struct name="fastest"><purpose>Speed is more important than the choice in value. </purpose></struct><struct name="nearest_even"/><struct name="nearest_odd"/><struct name="negative"><purpose>Round towards negative infinity. This mode is useful in interval arithmetic. </purpose></struct><struct name="positive"><purpose>Round towards positive infinity. This mode is useful in interval arithmetic. </purpose></struct><struct name="truncated"><purpose>Round towards zero. This mode is useful in implementing integral arithmetic. </purpose></struct></namespace>
<function name="abs"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter></function>
<function name="fabs"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter></function>
<function name="frexp"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter><parameter name="expptr"><paramtype>int *</paramtype></parameter></function>
<function name="ldexp"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter><parameter name="exp"><paramtype>int</paramtype></parameter></function>
<function name="sqrt"><type><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</type><template>
          <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
          <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
          <template-type-parameter name="round_mode"/>
          <template-type-parameter name="overflow_mode"/>
        </template><parameter name="x"><paramtype><classname>negatable</classname>&lt; integral_range, fractional_resolution, round_mode, overflow_mode &gt;</paramtype></parameter></function>
</namespace>
</namespace>
<namespace name="std">
<class-specialization name="numeric_limits"><template>
      <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
      <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
    </template><specialization><template-arg>boost::fixed_point::negatable&lt; integral_range</template-arg><template-arg>fractional_resolution</template-arg><template-arg>boost::fixed_point::round::fastest</template-arg><template-arg>boost::fixed_point::overflow::undefined &gt;</template-arg></specialization><description><para><note><para>Individual template specializations need to be provided </para></note>
</para></description><data-member name="is_specialized" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="digits" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="is_signed" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_integer" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_exact" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="radix" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="has_infinity" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_quiet_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_signaling_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_denorm" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_denorm_style</type></data-member>
<data-member name="has_denorm_loss" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_iec559" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_bounded" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_modulo" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="traps" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="tinyness_before" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="round_style" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_round_style</type></data-member>
<method-group name="public static functions">
<method name="min" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname>()</type></method>
<method name="max" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname>()</type></method>
<method name="lowest" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="epsilon" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="round_error" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="infinity" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="quiet_NaN" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
</method-group>
</class-specialization><class-specialization name="numeric_limits"><template>
      <template-nontype-parameter name="integral_range"><type>const int</type></template-nontype-parameter>
      <template-nontype-parameter name="fractional_resolution"><type>const int</type></template-nontype-parameter>
    </template><specialization><template-arg>boost::fixed_point::negatable&lt; integral_range</template-arg><template-arg>fractional_resolution</template-arg><template-arg>boost::fixed_point::round::nearest_even</template-arg><template-arg>boost::fixed_point::overflow::undefined &gt;</template-arg></specialization><data-member name="is_specialized" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="digits" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_digits10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="is_signed" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_integer" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_exact" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="radix" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="min_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="max_exponent10" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST int</type></data-member>
<data-member name="has_infinity" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_quiet_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_signaling_NaN" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="has_denorm" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_denorm_style</type></data-member>
<data-member name="has_denorm_loss" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_iec559" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_bounded" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="is_modulo" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="traps" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="tinyness_before" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST bool</type></data-member>
<data-member name="round_style" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST std::float_round_style</type></data-member>
<method-group name="public static functions">
<method name="min" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname>()</type></method>
<method name="max" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname>()</type></method>
<method name="lowest" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="epsilon" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="round_error" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="infinity" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
<method name="quiet_NaN" cv="noexcept" specifiers="static"><type>BOOST_CONSTEXPR_OR_CONST <classname>negatable_type</classname></type></method>
</method-group>
</class-specialization></namespace>
</header>
</library-reference>
